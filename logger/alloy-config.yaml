server:
  http_listen_port: 12345
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  # Push directly to Loki inside the Docker network (no bearer needed internally).
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: docker
    docker_sd_configs:
      - host: unix:///var/run/docker.sock
        refresh_interval: 10s

    # (Optional) Drop logs from the logging stack itself to reduce noise
    relabel_configs:
      - source_labels: [__meta_docker_container_name]
        regex: '/?(qoe-alloy|qoe-grafana|qoe-loki)'
        action: drop

      # container name (strip leading /)
      - source_labels: [__meta_docker_container_name]
        regex: '/?(.*)'
        target_label: container
      - source_labels: [__meta_docker_container_image]
        target_label: image
      - source_labels: [__meta_docker_container_id]
        target_label: container_id
      - source_labels: [__meta_docker_container_label_com_docker_compose_service]
        target_label: compose_service
      - source_labels: [__meta_docker_container_label_com_docker_compose_project]
        target_label: compose_project
      # optional labels you might add in compose
      - source_labels: [__meta_docker_container_label_env]
        target_label: env
      - source_labels: [__meta_docker_container_label_stack]
        target_label: stack
      # prefer compose service, fallback to container name
      - source_labels: [__meta_docker_container_label_com_docker_compose_service, __meta_docker_container_name]
        separator: ';'
        regex: '(.+);(.+)'
        replacement: '$1'
        target_label: service
      # path to the Docker JSON log
      - source_labels: [__meta_docker_container_id]
        target_label: __path__
        replacement: /var/lib/docker/containers/$1/$1-json.log

    pipeline_stages:
      # 1) multiline: join stack traces into single log entry
      - multiline:
          firstline: '^(?:\{|\d{4}-\d{2}-\d{2}T|\d{2}:\d{2}:\d{2})'
          max_wait_time: 2s

      # 2) parse Docker JSON wrapper (time, stream, attrs, log)
      - docker: {}

      # 3) try to parse inner JSON logs
      - json:
          expressions:
            time: time
            level: level
            severity: severity
            msg: msg
            message: message
            method: method
            path: path
            status: status
            duration: duration
            request_id: request_id
          optional: true

      # 4) logfmt fallback
      - logfmt:
          mapping:
            level: level
            msg: msg
            request_id: request_id
            duration: duration
          optional: true

      # 5) extract HTTP method/path/status as a last resort
      - regex:
          expression: '"(?P<method>GET|POST|PUT|DELETE|PATCH|OPTIONS) (?P<path>[^ ]+) HTTP/[0-9.]+"'
          source: message
          optional: true
      - regex:
          expression: '(?P<status>\b[1-5][0-9]{2}\b)'
          source: message
          optional: true

      # 6) promote useful fields into labels (be selective)
      - labels:
          level:
          severity:
          compose_service:
          compose_project:
          image:
          container:
          container_id:
          service:
          env:
          stack:
          method:
          path:
          status:
          request_id:

      # 7) stderr => severity=error
      - match:
          selector: '{stream="stderr"}'
          stages:
            - labels: { severity: error }

      # 8) status-based severity
      - match:
          selector: '{status=~"5.."}'
          stages:
            - labels: { severity: error }
      - match:
          selector: '{status=~"4.."}'
          stages:
            - labels: { severity: warn }

      # 9) level-based severity
      - match:
          selector: '{level=~"(?i)error|err|fatal|critical"}'
          stages:
            - labels: { severity: error }

      # 10) try to infer level from message text
      - regex:
          expression: '(?i)(?:level=|severity=|lvl=|\[)(error|warn|warning|info|debug|trace|fatal)'
          source: message
          target: level_extracted
          optional: true
      - match:
          selector: '{level_extracted!=""}'
          stages:
            - template: { source: level_extracted, template: '{{.}}' }
            - labels: { level: }
